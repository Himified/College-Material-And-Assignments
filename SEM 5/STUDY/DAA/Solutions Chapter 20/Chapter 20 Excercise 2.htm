
<!-- saved from url=(0062)https://www.cise.ufl.edu/~sahni/dsaac/instruct/exer/c20/e2.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="./Chapter 20 Excercise 2_files/exer.css">
</head>
<body class="vsc-initialized">
<h1>
Data Structures, Algorithms, &amp; Applications in C++<br>
Chapter 20, Exercise 2<br>
<br>
</h1>

<dl compact="">
<dt>(a)
</dt><dd>
The solution space tree is given below. The nodes are numbered <code class="var">1-66</code>.
<br><br>
<pre class="figure">                                     1
                                     |
                                   1 |
                                     2
                                     |
                                     |
                  ___________________|_____________________
                 /                /      \                 \
               /                 /        \                 \    
              /                 /          \                 \
          2  /              3  /         4  \             5   \
            /                 /              \                 \
           /                 /                \                 \
           3                4                 5                 6
          /|\              /|\               /|\               /|\
         / | \            / | \             / | \             / | \
      3 / 4|  \ 5      2 / 4|  \ 5       2 / 3|  \ 5       2 / 3|  \ 4
       /   |   \        /   |   \         /   |   \         /   |   \
      /    |    \      /    |    \       /    |    \       /    |    \
     /     |     \    /     |     \     /     |     \     /     |     \
     7     8     9    10    11    12    13    14    15    16    17    18
     |     |     |     |     |     |     |     |     |     |     |     |
   4/ \5 3/ \5 3/ \4 4/ \5 2/ \5 2/ \4 3/ \5 2/ \5 2/ \3 3/ \4 2/ \4 2/ \3
   19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42
    | |   | |   | |   | |   | |   | |   | |   | |   | |   | |   | |   | |
   5| |4 5| |3 4| |3 5| |4 5| |2 4| |2 5| |3 5| |2 3| |2 4| |3 4| |2 3| |2
    | |   | |   | |   | |   | |   | |   | |   | |   | |   | |   | |   | |
   43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66
</pre><br><br>
</dd><dt>(b)
</dt><dd>
The backtracking algorithm starts at node
<code class="var">1</code>
of the tree and moves to node
<code class="var">2</code>. This corresponds to starting the tour at vertex
<code class="var">1</code> of the graph of Figure 16.6. Next we move to node
<code class="var">3</code> of the tree. At this point the partial tour is
<code class="var">1, 2</code> and the cost of this partial tour is
<code class="var">8</code>. From node
<code class="var">3</code>, we move to node
<code class="var">7</code>, and the partial tour becomes
<code class="var">1, 2, 3</code>. The cost of this partial tour is
<code class="var">13</code>. The backtracking algorithm now moves to node
<code class="var">19</code>. The partial tour here is
<code class="var">1, 2, 3, 4</code>, and its cost is
<code class="var">33</code>. Node 43 is the next tree node that is reached.
The partial tour here is
<code class="var">1, 2, 3, 4, 5</code>, and its cost is
<code class="var">35</code>. Node
<code class="var">43</code> is a leaf node. However, this leaf node
is node adjacent to the start vertex, vertex
<code class="var">1</code>, of the tour. Therefore, the partial tour
cannot be completed into a tour.
<br><br>
From node
<code class="var">43</code>, we backtrack to node
<code class="var">19</code> and then to node
<code class="var">7</code>. From node
<code class="var">7</code>, we attempt to move forward to node
<code class="var">20</code>. However, node
<code class="var">20</code> represents a move to vertex
<code class="var">5</code> and the graph has no edge between
vertices
<code class="var">3</code> and
<code class="var">5</code>. Therefore, the move to node
<code class="var">20</code> is infeasible, and we continue to backtrack
on the path from the root.
<br><br>
We move bck to node
<code class="var">3</code>.  This node has two unexplored children, nodes
<code class="var">8</code> and
<code class="var">9</code>. We first move to node
<code class="var">8</code>.  The partial tour is now
<code class="var">1, 2, 4</code>, and its cost is
<code class="var">18</code>. From node
<code class="var">8</code>, we reach node
<code class="var">21</code>. From node
<code class="var">21</code>, however, we are unable to move to
node
<code class="var">45</code>, which is the only child of node
<code class="var">21</code> (because the graph does not have an edge
between vertices
<code class="var">3</code> and
<code class="var">5</code>. So, from node
<code class="var">21</code>, we backtrack to node
<code class="var">8</code>, and then move forward to node
<code class="var">22</code>. The only child of node
<code class="var">22</code> is not moved to because the graph does not
have an edge between vertices
<code class="var">5</code> and
<code class="var">3</code>.
<br><br>
The algorithm now backs up to node
<code class="var">3</code> and then moves forward to node
<code class="var">9</code>.  The partial tour at this node is
<code class="var">1, 2, 5</code>, and its cost is
<code class="var">14</code>. Since the edge
<code class="var">(5,3)</code> is not present in the graph, we do not
move to node
<code class="var">23</code>. The next move is to node
<code class="var">24</code>, and from there to the leaf node
<code class="var">48</code>. The partial tour at this leaf is
<code class="var">1, 2, 5, 4, 3</code>.  The partial tour is now completed
into the tour
<code class="var">1, 2, 5, 4, 3, 1</code>.  The cost of this tour
is
<code class="var">42</code>.
<br><br>
From node
<code class="var">48</code>, we back up all the way to node
<code class="var">2</code>. From here, we can again move forward.
The next move is to node
<code class="var">4</code>. The cost of the partial tour,
<code class="var">1, 3</code>, at this node is <code class="var">6</code>.
From node
<code class="var">4</code>, we move to nodes
<code class="var">10</code>,
<code class="var">25</code>, and
<code class="var">49</code>. The cost of the partial tour
<code class="var">1, 3, 2, 4, 5</code>, at node
<code class="var">49</code>
is <code class="var">23</code>. Since, there is no
edge between vertices
<code class="var">5</code> and
<code class="var">1</code>,
we are now at an infeasible leaf, and we backtrack first to node
<code class="var">25</code> and then to node
<code class="var">10</code>. 
From node <code class="var">10</code>, the algorithm moves forward to nodes
<code class="var">26</code> and
<code class="var">50</code>. At node
<code class="var">50</code>, the partial tour
<code class="var">1, 3, 2, 5, 4</code> is completed to obtain the tour
<code class="var">1, 3, 2, 5, 4, 1</code> which has a cost of
<code class="var">23</code>.
Since this tour has  smaller cost than the tour found at node
<code class="var">48</code>, we discard the earlier found tour.
<br><br>
From node
<code class="var">50</code>, we back up to nodes
<code class="var">26</code>,
<code class="var">10</code>, and
<code class="var">4</code>. 
From here, we attempt to move forward to one of the remaining
children of node
<code class="var">4</code>.
We do not move to node
<code class="var">11</code>, because the partial tour
<code class="var">1, 3, 4</code>
defined at this node has a cost,
<code class="var">26</code>, which exceeds that of the best tour found so far.
Therefore, the subtree rooted at node
<code class="var">11</code> cannot contain a tour that is better than the
best tour found so far. We also do not move to node
<code class="var">12</code>. This is because the graph does not have an
edge between the vertices
<code class="var">3</code> and
<code class="var">5</code>. Since we cannot move forward from node 
<code class="var">4</code>, we back up further to node
<code class="var">2</code> and then move forward to
<code class="var">5</code> which defines the partial tour
<code class="var">1, 4</code>.
<br><br>
From node
<code class="var">5</code>, we move forward to nodes
<code class="var">13</code> and
<code class="var">31</code>. The partial tour at node
<code class="var">31</code> is
<code class="var">1, 4, 2, 3</code>, and its cost is
<code class="var">19</code>.
We are unable to extend this partial tour by making a move to node
<code class="var">55</code>, because our graph does not have an edge
between vertices
<code class="var">3</code> and
<code class="var">5</code>.  Therefore, we backup to node
<code class="var">13</code> and then move forward to node
<code class="var">32</code>. We cannot move forward from this node
because there is no edge between the vertices
<code class="var">5</code> and
<code class="var">3</code>.  Therefore, we backup to node
<code class="var">13</code> and then to node
<code class="var">5</code>.
<br><br>
From node
<code class="var">5</code>, we attempt to move forward to node
<code class="var">14</code>. However, the cost of the partial tour
<code class="var">1, 4, 3</code> defined at this node is
<code class="var">24</code>, which exceeds the cost of the best tour so far.
Therefore, we do not move to node
<code class="var">14</code>. The next move is to node
<code class="var">15</code> which represents the partial tour
<code class="var">1, 4, 5</code> whose cost is
<code class="var">6</code>.  The next moves are to nodes
<code class="var">35</code> and
<code class="var">59</code>.  The partial tour at node
<code class="var">59</code> is
<code class="var">1, 4, 5, 2, 3</code>. When this is completed into a tour,
the tour cost is
<code class="var">23</code>. This tour is discarded because it is no better
than the best tour found so far.  We backup to nodes
<code class="var">35</code> and
<code class="var">15</code>. We cannot move forward to node
<code class="var">36</code> because the edge
<code class="var">(5,3)</code> is not present in the graph.
Therefore, we backup to node
<code class="var">5</code> and then to node
<code class="var">2</code>.
<br><br>
Node
<code class="var">6</code> is the only child of node
<code class="var">2</code> that has not been exploerd so far.
However, since the edge
<code class="var">(1,5)</code> is not present in the graph, we do not move
to node
<code class="var">6</code>. The algorithm backs up to node
<code class="var">1</code> and then terminates with
<code class="var">1, 4, 5, 2, 3, 1</code> as the least cost tour.
<br><br>
The nodes are reached in the order
<code class="var">1, 2, 3, 7, 19, 43, 8, 21, 22, 9, 24, 48, 4, 10,
25, 49, 26, 50, 5, 13, 31, 32, 59, 15, 35</code>. Nodes not listed are
not rached by the algorithm. Although a node may be reached more than once,
each node is listed only once (i.e., the first time a move is made to that node).



 







</dd></dl></body></html>